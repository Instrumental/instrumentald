#!/usr/bin/env ruby

require 'rubygems'
begin
  gem 'instrumental_agent'
rescue Gem::LoadError
  puts "Requires the Instrumental Agent gem:\n"
  puts '  gem install instrumental_agent'
  exit 1
end

require 'etc'
require 'instrumental_agent'
require 'fileutils'
require 'optparse'
require 'socket'
require 'tmpdir'

$: << File.join(File.dirname(__FILE__), "..", "lib")
require 'instrumentald/version'
require 'instrumentald/server_controller'

def coerce_path(path)
  if File::ALT_SEPARATOR
    File.expand_path(File.join(*path.split(File::ALT_SEPARATOR)))
  else
    File.expand_path(path)
  end
end


cur_directory         = Dir.pwd
home_directory        = Dir.home rescue nil
script_location       = File.expand_path(File.dirname(__FILE__))
tmp_dir               = Dir.tmpdir
script_data_directory = [cur_directory, home_directory, script_location, tmp_dir].compact.detect { |dir| File.writable?(dir) }

default_script_directory = File.join(script_data_directory, '.instrumental_scripts')
default_command          = :foreground

default_options = {
  :collector       => 'collector.instrumentalapp.com',
  :port            => '8001',
  :hostname        => Socket.gethostname,
  :pid_location    => File.join(script_data_directory, 'instrumentald.pid'),
  :log_location    => File.join(script_data_directory, 'instrumentald.log'),
  :tmp_location    => Dir.tmpdir,
  :enable_scripts  => false,
  :script_location => default_script_directory,
  :report_interval => 30,
  :debug           => false,
  :config_file     => '/etc/instrumentald.toml',
  :user            => nil
}
run_options = {}

define_method :options do
  default_options.merge(run_options)
end

option_parser = OptionParser.new do |opts|
  opts.banner = <<-EOBANNER
Usage: #{File.basename($0)} [options] [#{ServerController::COMMANDS.join('|')}]"
Default command: #{default_command.to_s}
  EOBANNER

  opts.on('-k', '--project_token PROJECT_TOKEN', 'A project token used for authentication, not required if you use config file.') do |project_token|
    run_options[:project_token] = project_token
  end

  opts.on('-c', '--config-file PATH', "Configuration path, required if using services(MySQL, redis, etc.) or if project token is not specififed. (default #{default_options[:config_file]})") do |path|
    run_options[:config_file] = coerce_path(path)
  end

  opts.on('-H', '--hostname HOSTNAME', "Hostname to report as (default #{default_options[:hostname]})") do |hostname|
    run_options[:hostname] = hostname
  end

  opts.on('-p', '--pid LOCATION', "Where daemon PID file is located (default #{default_options[:pid_location]})") do |pid_location|
    run_options[:pid_location] = coerce_path(pid_location)
  end

  opts.on('-l', '--log LOCATION', "Where to put the instrumentald log file (default #{default_options[:log_location]})") do |log_location|
    run_options[:log_location] = coerce_path(log_location)
  end

  opts.on('-r', '--report-interval INTERVAL_IN_SECONDS', "How often to report metrics to Instrumental (default #{default_options[:report_interval]})") do |interval|
    run_options[:report_interval] = interval.to_i
  end

  opts.on('-e', '--enable-scripts', "Enable custom metric gathering from local scripts (default #{default_options[:enable_scripts]})") do
    run_options[:enable_scripts] = true
  end

  opts.on('-s', '--script-location PATH_TO_DIRECTORY', "Directory where local scripts for custom metrics are located (default #{default_options[:script_location]})") do |path|
    run_options[:script_location] = coerce_path(path)
  end

  opts.on('-u', '--user USER_TO_RUN_AS', "User to run instrumentald as. You must have permissions to drop privileges to this user.") do |u|
    run_options[:user] = u
  end

  opts.on('-t', '--temp-dir TEMP_DIRECTORY', "Where to store temporary files (default #{default_options[:tmp_location]})") do |t|
    run_options[:tmp_location] = coerce_path(t)
  end

  opts.on('--debug', "Print all sent metrics to the log") do
    run_options[:debug] = true
  end

  opts.on('-h', '--help', 'Display this screen') do
    puts opts
    exit
  end

  opts.on('-v', '--version', 'Display version') do
    puts "instrumentald: #{Instrumentald::VERSION}"
    exit 0
  end
end

option_parser.parse!

if options[:user]
  desired_uid = Etc.getpwnam(options[:user]).uid
  Process::Sys.setuid(desired_uid)
  if desired_uid && desired_uid != 0
    begin
      Process::Sys.setuid(0)
    rescue Errno::EPERM
      nil
    else
      puts "Cannot drop privileges to #{options[:user]}"
      exit 1
    end
  end
end

command = ARGV.first && ARGV.first.to_sym
command ||= default_command


run_options[:project_token] ||= ENV["INSTRUMENTAL_TOKEN"]

def show_option_error(option_parser, message)
  STDERR.puts "ERROR: #{message}\n\n"
  print option_parser.help
  exit 1
end

# if options[:project_token].to_s.strip.empty? && !File.exist?(options[:config_file])
#   show_option_error option_parser, "You must provide a project token, or a config path that exists(#{options[:config_file]})"
# end

if options[:pid_location].to_s.strip.empty?
  show_option_error option_parser, "You must provide a valid path for the PID file (-p PID_PATH)"
end

if !File.directory?(File.dirname(options[:pid_location]))
  show_option_error option_parser, "The directory specified for the pid file #{options[:pid_location]} does not exist, please create"
end

if options[:log_location].to_s.strip.empty?
  show_option_error option_parser, "You must provide a valid path for the log file (-l LOG_PATH)"
end

if !File.directory?(File.dirname(options[:log_location]))
  show_option_error option_parser, "The directory specified for the log file #{options[:log_location]} does not exist, please create"
end

if options[:report_interval].to_i < 1
  show_option_error option_parser, "You must specify a reporting interval greater than 0"
end

if options[:enable_scripts]

  if options[:script_location].to_s.strip.empty?
    show_option_error option_parser, "You must specify a valid directory to execute custom scripts in."
  end

  if options[:script_location] == default_script_directory
    FileUtils.mkdir_p(default_script_directory, :mode => 0700)
  end

  if !File.directory?(options[:script_location])
    show_option_error option_parser, "The directory #{options[:script_location]} does not exist."
  end

  stat         = File::Stat.new(File.expand_path(options[:script_location]))
  correct_mode = ((stat.mode & 0xFFF) ^ 0O700) === 0
  unless stat.owned? && correct_mode
    uid      = Process.uid
    user = Etc.getpwuid(uid)
    username = if user.respond_to?(:name)
      user.name
    else
      "unknown"
    end
    show_option_error option_parser, "The directory #{options[:script_location]} is writable/readable by others. Please ensure it is only writable / readable by user/uid #{username}/#{uid}"
  end

end


running_as_daemon = [:start, :restart].include?(command)

controller = ServerController.spawn(
               :name            => File.basename(__FILE__),
               :path            => options[:tmp_location],
               :pid_file        => options[:pid_location],
               :verbose         => true,
               :log_file        => options[:log_location],
               :run_options     => run_options.merge(:daemon => running_as_daemon),
               :default_options => default_options,
             )

if ServerController::COMMANDS.include?(command)
  controller.send command
else
  raise "Command must be one of: #{ServerController::COMMANDS.join(', ')}"
end



if running_as_daemon
  sleep 1
  if !controller.running?
    raise "Failed to start process, see #{options[:log_location]}"
  end
end
